#!/usr/bin/env python3

import os
import shlex
import subprocess
import threading

from shell_helpers import LF
import common
from thread_pool import ThreadPool
import path_properties

class Main(common.BuildCliFunction):
    def __init__(self, *args, **kwargs):
        if not 'description' in kwargs:
            kwargs['description'] = '''\
Build our compiled userland examples.
'''
        super().__init__(*args, **kwargs)
        self.add_argument(
            'targets',
            default=[],
            help='''\
Select to build only the given userland programs, or all programs under
the given directories.

Default: build all.

Must point to either sources or directories under userland/, or to LKMC
toplevel which is a synonym for userland/.

Default: build all examples that have their package dependencies met, e.g.:

-   userland/arch/ programs only build if the target arch matches
-   an OpenBLAS example can only be built if the target root filesystem
    has the OpenBLAS libraries and headers installed, which you must inform
    with --package
''',
            nargs='*',
        )
        self._add_argument('--ccflags')
        self._add_argument('--force-rebuild')
        self._add_argument('--optimization-level')

    def _build_one(
        self,
        in_path,
        out_path,
        build_exts=None,
        cc_flags=None,
        cc_flags_after=None,
        extra_objs_userland_asm=None,
        extra_objs_lkmc_common=None,
        extra_deps=None,
        link=True,
    ):
        if cc_flags is None:
            cc_flags = []
        else:
            cc_flags = cc_flags.copy()
        if cc_flags_after is None:
            cc_flags_after = []
        else:
            cc_flags_after = cc_flags_after.copy()
        if extra_deps is None:
            extra_deps = []
        ret = 0
        in_dir, in_basename = os.path.split(in_path)
        in_dir_abs = os.path.abspath(in_dir)
        dirpath_relative_root = in_dir_abs[len(self.env['userland_source_dir']) + 1:]
        dirpath_relative_root_components = dirpath_relative_root.split(os.sep)
        dirpath_relative_root_components_len = len(dirpath_relative_root_components)
        my_path_properties = path_properties.get(os.path.join(
            self.env['userland_subdir'],
            dirpath_relative_root,
            in_basename
        ))
        if my_path_properties.should_be_built(self.env, link):
            extra_objs= []
            if my_path_properties['extra_objs_lkmc_common']:
                extra_objs.extend(extra_objs_lkmc_common)
            if my_path_properties['extra_objs_userland_asm']:
                extra_objs.extend(extra_objs_userland_asm)
            if self.need_rebuild([in_path] + extra_objs + extra_deps, out_path):
                cc_flags.extend(my_path_properties['cc_flags'])
                cc_flags_after.extend(my_path_properties['cc_flags_after'])
                if my_path_properties['cc_pedantic']:
                    cc_flags.extend(['-pedantic', LF])
                if not link:
                    cc_flags.extend(['-c', LF])
                in_ext = os.path.splitext(in_path)[1]
                if in_ext in (self.env['c_ext'], self.env['asm_ext']):
                    cc = self.env['gcc']
                    std = my_path_properties['c_std']
                elif in_ext == self.env['cxx_ext']:
                    cc = self.env['gxx']
                    std = my_path_properties['cxx_std']
                if dirpath_relative_root_components_len > 0:
                    if dirpath_relative_root_components[0] == 'arch':
                        cc_flags.extend([
                            '-I', os.path.join(self.env['userland_source_arch_arch_dir']), LF,
                            '-I', os.path.join(self.env['userland_source_arch_dir']), LF,
                        ])
                    elif dirpath_relative_root_components[0] == 'libs':
                        if dirpath_relative_root_components_len > 1:
                            if self.env['gcc_which'] == 'host':
                                eigen_root = '/'
                            else:
                                eigen_root = self.env['buildroot_staging_dir']
                            packages = {
                                'eigen': {
                                    # TODO: was failing with:
                                    # fatal error: Eigen/Dense: No such file or directory as of
                                    # 975ce0723ee3fa1fea1766e6683e2f3acb8558d6
                                    # http://lists.busybox.net/pipermail/buildroot/2018-June/222914.html
                                    'cc_flags': [
                                        '-I',
                                        os.path.join(
                                            eigen_root,
                                            'usr',
                                            'include',
                                            'eigen3'
                                        ),
                                        LF
                                    ],
                                    # Header only.
                                    'cc_flags_after': [],
                                },
                            }
                            package_key = dirpath_relative_root_components[1]
                            if package_key in packages:
                                package = packages[package_key]
                            else:
                                package = {}
                            if 'cc_flags' in package:
                                cc_flags.extend(package['cc_flags'])
                            else:
                                pkg_config_output = subprocess.check_output([
                                    self.env['pkg_config'],
                                    '--cflags',
                                    package_key
                                ]).decode()
                                cc_flags.extend(self.sh.shlex_split(pkg_config_output))
                            if 'cc_flags_after' in package:
                                cc_flags.extend(package['cc_flags_after'])
                            else:
                                pkg_config_output = subprocess.check_output([
                                    self.env['pkg_config'],
                                    '--libs',
                                    package_key
                                ]).decode()
                                cc_flags_after.extend(self.sh.shlex_split(pkg_config_output))
                os.makedirs(os.path.dirname(out_path), exist_ok=True)
                ret = self.sh.run_cmd(
                    (
                        [
                            cc, LF,
                        ] +
                        cc_flags +
                        [
                            '-std={}'.format(std), LF,
                            '-o', out_path, LF,
                            in_path, LF,
                        ] +
                        self.sh.add_newlines(extra_objs) +
                        cc_flags_after
                    ),
                    extra_paths=[self.env['ccache_dir']],
                )
        return ret

    def build(self):
        build_dir = self.get_build_dir()
        cc_flags = [
            '-I', self.env['root_dir'], LF,
            '-O{}'.format(self.env['optimization_level']), LF,
        ] + self.sh.shlex_split(self.env['ccflags'])
        if self.env['static']:
            cc_flags.extend(['-static', LF])
        extra_obj_lkmc_common = os.path.join(
            build_dir,
            self.env['common_basename_noext'] + self.env['obj_ext']
        )
        self._build_one(
            in_path=self.env['common_c'],
            out_path=extra_obj_lkmc_common,
            cc_flags=cc_flags,
            extra_deps=[self.env['common_h']],
            link=False,
        )
        extra_obj_userland_asm = os.path.join(
            build_dir,
            'arch',
            'main' + self.env['obj_ext']
        )
        extra_obj_userland_asm_relpath = os.path.join(
            'arch',
            'main' + self.env['c_ext']
        )
        self._build_one(
            in_path=os.path.join(
                self.env['userland_source_dir'],
                extra_obj_userland_asm_relpath
            ),
            out_path=extra_obj_userland_asm,
            cc_flags=cc_flags,
            extra_deps=[self.env['common_h']],
            link=False,
        )
        with ThreadPool(
            self._build_one,
            nthreads=self.env['nproc'],
        ) as thread_pool:
            try:
                for target in self.env['targets']:
                    for path, in_dirnames, in_filenames in self.sh.walk(target):
                        for in_filename in in_filenames:
                            in_ext = os.path.splitext(in_filename)[1]
                            if not in_ext in self.env['userland_in_exts']:
                                continue
                            in_path = os.path.join(path, in_filename)
                            error = thread_pool.submit({
                                'in_path': in_path,
                                'out_path': self.resolve_userland_executable(in_path),
                                'cc_flags': cc_flags,
                                'extra_objs_lkmc_common': [extra_obj_lkmc_common],
                                'extra_objs_userland_asm': [extra_obj_userland_asm],
                            })
                            if error is not None:
                                raise common.ExitLoop()
            except common.ExitLoop:
                pass
        error = thread_pool.get_error()
        if error is not None:
            print(error)
            return 1
        if not self.env['in_tree']:
            self.sh.copy_dir_if_update(
                srcdir=build_dir,
                destdir=self.env['out_rootfs_overlay_lkmc_dir'],
                filter_ext=self.env['userland_executable_ext'],
            )
        return 0

    def clean(self):
        if self.env['in_tree']:
            for target in self.env['targets']:
                if os.path.exists(target):
                    if os.path.isfile(target):
                        self.sh.rmrf(self.resolve_userland_executable(target))
                    else:
                        for path, dirnames, filenames in self.sh.walk(target):
                            for filename in filenames:
                                if os.path.splitext(filename)[1] in self.env['userland_out_exts']:
                                    self.sh.rmrf(os.path.join(path, filename))
        else:
            for target in self.env['targets']:
                self.sh.rmrf(self.resolve_userland_executable(target))

    def get_build_dir(self):
        return self.env['userland_build_dir']

    def setup_one(self):
        self.env['targets'] = self.resolve_targets(
            self.env['userland_source_dir'],
            self.env['targets']
        )

if __name__ == '__main__':
    Main().cli()
